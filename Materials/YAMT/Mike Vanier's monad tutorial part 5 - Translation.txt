Еще Одно Руководство по Монадам (часть 5: Монады для обработки ошибок)
Mike Vanier
http://mvanier.livejournal.com

Перевод: Гранин А. С.
graninas@gmail.com

By Mike Vanier

В прошлой статье мы узнали, как задать и использовать монаду *-Maybe*- и монаду списка. В этой и следующей статье мы посмотрим на монады для обработки ошибок, которые также называются исключениями.

Вычисления с обработкой ошибок

Этот вид вычислений будет иметь тип, схематически представленный так:

a --[возможный провал из-за ошибочных условий]--> b

На словах, эти вычисления отображают значение типа *-a*- на выходное значение типа *-b*-, но они могут провалиться в специфических ошибочных случаях, а не вернуть значение типа *-b*-. Похоже на монаду *-Maybe*-, но разница в том, что в *-Maybe*- все ошибки одинаковы и неразличимы - это значение *-Nothing*-. Наоборот, в монаде обработки исключений обычно бывают разные значения ошибок, возвращаемые при сбое. Кроме того, хорошо было бы иметь удобный механизм для отлова ошибок и восстановления ошибочной ситуации (то, что в большинстве языков программирования делается неким __механизмом обработки исключений__). Вы еще увидите, как можно собрать свою систему отслеживания ошибок.

Обработка ошибок в *-Haskell*-

В языке *-Haksell*- есть очень много возможностей ловить ошибки, - может быть, даже слишком много. Вот список:

* Функция error
* Исключения в монаде *-IO*-
* Расширяемые исключения
* Монадические исключения

Давайте рассмотрим каждую из возможностей.

Функция error

Многие хаскеллисты знают о функции error. error служит для обрыва вычислений, которые не могут быть успешными. Факториал отрицательного аргумента - хороший пример тому:

  factorial :: Integer -> Integer
  factorial n | n < 0 = error "factorial: negative argument"
  factorial 0 = 1
  factorial n = n * factorial (n - 1)
  
У ошибки error очень интересный тип:

error :: String -> a

Это значит, что error принимает String как аргумент и может "вернуть" значение вообще любого типа. Но конечно же, функция error __ничего не возвращает__ в обычном понимании: на ней же вычисления просто прерываются. На самом деле такой тип может быть любым, подходящим по контексту, чтобы тайп-чекер был доволен и не ругался. (В примере factorial функция error "возвращает" Integer).

Обычно функцию error не используют для обработки ошибок. То есть, там, где из ошибочной ситуации нужно как-то выбраться, error не поможет. И хотя ошибку, выброшенную функцией error, можно отловить, это можно сделать только в монаде IO. Раскрывать детали я не буду (изучайте документацию по GHC), но считаю, что это хак. Функциональный код должен быть __функциональным__, то есть, не должно быть никаких скрытых действий, - все должно быть понятно из типа. С другой стороны, я понимаю, откуда взялся этот хак. Посмотрите на другую версию факториала:

  factorial :: Integer -> Integer
  factorial 0 = 1
  factorial n = n * factorial (n - 1)

Ужасного error теперь нет, но функция уйдет в бесконечный цикл, если ее вызвать с отрицательным аргументом. Ограничьте второе определение только положительными значениями:

  factorial :: Integer -> Integer
  factorial 0 = 1
  factorial n | n > 0 = n * factorial (n - 1)

и вы получите ошибку сопоставления с образцом, выполнение тоже прервется, и никакого Integer вы не получите. Функция error - это компромисс, на который пошли, чтобы программист смог записать __полные__ определения функций (то есть, когда все варианты учтены) даже для невалидных аргументов.

Но есть способ более понятный, мы познакомимся с ним позже.

