Еще Одно Руководство по Монадам (часть 5: Монады для обработки ошибок)
Mike Vanier
http://mvanier.livejournal.com

Перевод: Гранин А. С.
graninas@gmail.com

By Mike Vanier

В прошлой статье мы узнали, как задать и использовать монаду *-Maybe*- и монаду списка. В этой и следующей статье мы посмотрим на монады для обработки ошибок, которая также известна как обработка исключений.

Вычисления с обработкой ошибок

Вид вычислений с обработкой ошибок должен быть такого типа, который можно схематически представить так:

a --[возможный провал из-за специфических ошибочных условий]--> b

На словах, эти вычисления отображают входное значение типа *-a*- на выходное значение типа *-b*-, но вместо возврата значения типа *-b*-, они могут провалиться в специфических ошибочных случаях. По-видимому, это очень похоже на монаду *-Maybe*-. Отличие в том, что в *-Maybe*- все сбои неразличимы (возвращается значение *-Nothing*-). В противоположность монаде *-Maybe*-, в монадах обработки ошибок обычно есть несколько разнообразных и различимых ошибочных условий, которые могут привести к сбою вычисления. Еще одно отличие в том, что при выполнении вычислений с обработкой ошибок хотелось бы иметь механизм отлова ошибок и выхода из ошибочных ситуаций контролируемым образом (в большинстве языков программирования это делается __механизмом исключений__). Вы еще увидите, как легко можно собрать собственную систему отслеживания ошибок. {В ориг. - "roll your own", устойчивое выражение, означающее "собрать собственными руками". - Прим. пер.}

Обработка ошибок в *-Haskell*-

В языке *-Haksell*- для программиста, желающего написать код, который может завершиться неудачей, есть очень много возможностей (может быть даже слишком много). В наиболее общий набор входят:

* Функция error
* Исключения в монаде *-IO*-
* Расширяемые исключения
* Монадические исключения

Рассмотрим каждую из возможностей.

Функция error

Большинство Haskell-программистов знают о функции error. Она используется просто для обрыва вычислений, которые не могут быть успешными. Хорошим примером будет факториал от отрицательного значения:

  factorial :: Integer -> Integer
  factorial n | n < 0 = error "factorial: negative argument"
  factorial 0 = 1
  factorial n = n * factorial (n - 1)
  
У ошибки error очень интересный тип:

error :: String -> a

Это значит, что error принимает String как аргумент и может "вернуть" значение вообще любого типа. Но конечно же, функция error __ничего не возвращает__ в обычном понимании (в том-то и дело, что она прекращает вычисления). На самом деле такой тип функции значит, что он может быть любым, подходящим здесь, чтобы проходила проверка типов (в примере factorial тип возвращаемого значения функции error становится Integer).

Обычно error не подходит для обработки ошибок. То есть, там, где из ошибочной ситуации нужно как-то выбраться, error не поможет. И хотя ошибки, выброшенные функцией error, отлавливаются, они отлавливаются в монаде IO. Вдаваться в детали я не буду (изучайте документацию по GHC), но считаю, что это хак. Функциональный код должен быть __функциональным__, а значит, запрещено непонятное скрытое поведение, которое не прослеживается из типа. С другой стороны, я понимаю, откуда взялся этот момент. Посмотрите на другую версию факториала:

  factorial :: Integer -> Integer
  factorial 0 = 1
  factorial n = n * factorial (n - 1)

Ужасного error теперь нет, но функция уйдет в бесконечный цикл, если ее вызвать с отрицательным значением. Ограничьте второе определение только положительными значениями:

  factorial :: Integer -> Integer
  factorial 0 = 1
  factorial n | n > 0 = n * factorial (n - 1)

и вы получите ошибку сопоставления с образцом, которая тоже прервет выполнение, и никакого Integer функция не вернет. Функция error - это компромисс, на который пошли, чтобы программист смог записать __полные__ определения функций (то есть, когда все варианты учтены) даже для невалидных аргументов.

Но есть способ более понятный, мы познакомимся с ним вдальнейшем.

